<!-- Web 服务器验证方式说明 -->
<div class="verification-method" id="webserver-method">
    <h3>
        <svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="3" y="3" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2"/>
            <path d="M3 9H21" stroke="currentColor" stroke-width="2"/>
            <circle cx="6.5" cy="6" r="0.5" fill="currentColor"/>
            <circle cx="8.5" cy="6" r="0.5" fill="currentColor"/>
            <circle cx="10.5" cy="6" r="0.5" fill="currentColor"/>
        </svg>
        方式 A：Web 服务器验证（HTTP-01）
    </h3>

    <div class="method-description">
        <p>通过在您的 Web 服务器上放置验证文件来证明域名所有权。适用于有公网可访问 Web 服务器的场景。</p>
        <p style="color: red">配置完成后一定要使其生效比如【nginx -s reload】重新加载nginx</p>
    </div>

    <div class="method-steps">
        <h4>操作步骤：</h4>
        <ol>
            <li>
                <strong>创建验证文件目录：</strong>
                <pre><code>mkdir -p /var/www/html/.well-known/acme-challenge</code></pre>
            </li>
            <li>
                <strong>创建验证文件：</strong>
                <p>文件名：<code id="challenge-filename">xxxxxxxxxxxx</code></p>
                <p>文件内容：<code id="challenge-content">xxxxxxxxxxxx.yyyyyyyyyyyy</code></p>
                <pre><code>echo "验证内容" > /var/www/html/.well-known/acme-challenge/验证文件名</code></pre>
            </li>
            <li>
                <strong>配置 Nginx（示例）：
                    <button type="button" class="help-toggle-btn" onclick="toggleNginxExamples()" title="查看完整配置示例">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                            <path d="M12 16V12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            <circle cx="12" cy="8" r="1" fill="currentColor"/>
                        </svg>
                    </button>
                </strong>
                <pre><code>server {
    listen 80;
    server_name <span class="domain-placeholder">example.com</span>;

    location /.well-known/acme-challenge/ {
        root /var/www/html;
        try_files $uri =404;
    }
}</code></pre>

                <!-- 完整配置示例（可展开） -->
                <div class="nginx-examples-container" id="nginx-examples" style="display: none;">
                    <div class="example-header">
                        <h5>完整 Nginx 配置示例</h5>
                    </div>

                    <div class="example-section">
                        <h6>场景 1：标准静态站点配置</h6>
                        <pre><code>server {
    listen 80;
    server_name <span class="domain-placeholder">example.com</span>;
    root /var/www/html;

    # 确保 ACME 验证路径可访问
    location /.well-known/acme-challenge/ {
        try_files $uri =404;
    }
}</code></pre>
                    </div>

                    <div class="example-section">
                        <h6>场景 2：反向代理配置（推荐）</h6>
                        <p class="example-note">适用于使用 nginx 作为反向代理，所有请求都通过 proxy_pass 转发的场景</p>
                        <pre><code>server {
    listen 80;
    server_name <span class="domain-placeholder">example.com</span>;

    # ✅ ACME 验证路径 - 使用 ^~ 优先匹配，防止被其他规则拦截
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;
        try_files $uri =404;
    }

    # 其他请求转发到后端
    location / {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}</code></pre>
                    </div>

                    <div class="example-section example-important">
                        <h6>⚠️ 场景 3：HTTP 自动跳转 HTTPS（最常见且易错）</h6>
                        <p class="example-note error">很多生产环境会配置 HTTP 自动跳转到 HTTPS，这会导致 ACME 验证失败！</p>

                        <div class="example-wrong">
                            <p><strong>❌ 错误配置（会导致验证失败）：</strong></p>
                            <pre><code>server {
    listen 80;
    server_name <span class="domain-placeholder">example.com</span>;

    # ❌ 所有请求都重定向到 HTTPS，Let's Encrypt 无法访问验证文件
    rewrite ^(.*) https://$server_name$1 permanent;
}</code></pre>
                        </div>

                        <div class="example-correct">
                            <p><strong>✅ 正确配置（推荐）：</strong></p>
                            <pre><code>server {
    listen 443 ssl;
    server_name <span class="domain-placeholder">example.com</span>;
    ssl_certificate /path/to/<span class="domain-placeholder">example.com</span>.pem;
    ssl_certificate_key /path/to/<span class="domain-placeholder">example.com</span>.key;

    location / {
        # 你的应用配置
        proxy_pass http://localhost:8080/;
    }
}

server {
    listen 80;
    server_name <span class="domain-placeholder">example.com</span>;

    # ✅ ACME 验证路径（使用 ^~ 优先匹配，必须在 rewrite 之前）
    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;
        try_files $uri =404;
    }

    # ✅ 其他请求重定向到 HTTPS（放在 location / 中）
    location / {
        rewrite ^(.*) https://$server_name$1 permanent;
    }
}</code></pre>
                        </div>

                        <div class="example-tips">
                            <p><strong>配置说明：</strong></p>
                            <ul>
                                <li><code>^~</code> 表示优先匹配，优先级高于正则和普通 location</li>
                                <li><strong>关键：</strong><code>.well-known</code> location 必须在 <code>location /</code> 之前或使用 <code>^~</code> 提高优先级</li>
                                <li>只有 <code>/.well-known/acme-challenge/</code> 路径不重定向</li>
                                <li>其他所有请求仍然重定向到 HTTPS</li>
                            </ul>
                        </div>

                        <div class="example-verify">
                            <p><strong>验证配置是否正确：</strong></p>
                            <pre><code># 1. 创建测试文件
mkdir -p /var/www/html/.well-known/acme-challenge
echo "test" > /var/www/html/.well-known/acme-challenge/test.txt

# 2. 重载 nginx 配置
nginx -t && nginx -s reload

# 3. 测试 HTTP 访问（应该返回 "test"，HTTP 200，不应该重定向）
curl -v http://<span class="domain-placeholder">example.com</span>/.well-known/acme-challenge/test.txt

# 预期结果：
# &lt; HTTP/1.1 200 OK
# test

# 4. 如果看到 301/302 或 https://，说明配置有问题
# 5. 如果返回 404，检查 root 路径
# 6. 清理测试文件
rm /var/www/html/.well-known/acme-challenge/test.txt</code></pre>
                        </div>
                    </div>

                    <div class="example-section">
                        <h6>场景 4：多域名共用一个服务器</h6>
                        <p class="example-note">多个域名可以共用同一个 <code>/.well-known/acme-challenge/</code> 目录</p>
                        <pre><code># 目录结构（所有域名共用）
/var/www/html/.well-known/acme-challenge/
├── abc123...xyz  (example.com 的验证文件)
├── def456...uvw  (blog.example.com 的验证文件)
└── ghi789...rst  (api.example.com 的验证文件)

# Nginx 配置示例
server {
    listen 80;
    server_name example.com;

    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;
        try_files $uri =404;
    }

    location / {
        rewrite ^(.*) https://$server_name$1 permanent;
    }
}

server {
    listen 80;
    server_name blog.example.com;

    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;  # 所有域名指向同一个目录
        try_files $uri =404;
    }

    location / {
        rewrite ^(.*) https://$server_name$1 permanent;
    }
}

server {
    listen 80;
    server_name api.example.com;

    location ^~ /.well-known/acme-challenge/ {
        root /var/www/html;  # 所有域名指向同一个目录
        try_files $uri =404;
    }

    location / {
        rewrite ^(.*) https://$server_name$1 permanent;
    }
}</code></pre>
                        <div class="example-tips">
                            <p><strong>为什么可以共用目录？</strong></p>
                            <ul>
                                <li><strong>验证文件名唯一：</strong>每个域名的验证文件名都是随机生成的（如 <code>abc123xyz...</code>），不会冲突</li>
                                <li><strong>Let's Encrypt 只访问对应域名的文件：</strong>申请 <code>example.com</code> 证书时，只会访问 <code>http://example.com/.well-known/acme-challenge/abc123xyz</code></li>
                                <li><strong>简化管理：</strong>所有验证文件放在同一个目录，便于统一管理和清理</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </li>
            <li>
                <strong>配置 Apache（示例）：</strong>
                <pre><code>&lt;VirtualHost *:80&gt;
    ServerName <span class="domain-placeholder">example.com</span>
    DocumentRoot /var/www/html

    &lt;Directory "/var/www/html/.well-known/acme-challenge"&gt;
        Require all granted
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;</code></pre>
            </li>
            <li>
                <strong>配置 Tomcat（示例）：</strong>
                <p>将 <code>.well-known</code> 目录放在 webapp 根目录下，确保可以通过 HTTP 访问。</p>
            </li>
            <li>
                <strong>重启 Web 服务器：</strong>
                <pre><code># Nginx
sudo systemctl reload nginx

# Apache
sudo systemctl reload apache2

# Tomcat
# 重启 Tomcat 服务</code></pre>
            </li>
            <li>
                <strong>验证访问：</strong>
                <p>确保可以通过浏览器或 curl 访问：</p>
                <pre><code>curl http://<span class="domain-placeholder">example.com</span>/.well-known/acme-challenge/验证文件名</code></pre>
            </li>
        </ol>
    </div>

    <div class="method-notes">
        <h4>注意事项：</h4>
        <ul>
            <li>确保域名已正确解析到服务器 IP</li>
            <li>确保防火墙开放 80 端口</li>
            <li>验证文件需要通过 HTTP（非 HTTPS）访问</li>
            <li>验证文件无需扩展名</li>
            <li><strong>多域名场景：</strong>多个域名可以共用同一个 <code>/.well-known/acme-challenge/</code> 目录，因为每个域名的验证文件名都是唯一的随机字符串，不会冲突</li>
            <li><strong>目录权限：</strong>确保 nginx/apache 用户对 <code>/.well-known/acme-challenge/</code> 目录有读取权限</li>
        </ul>
    </div>
</div>
